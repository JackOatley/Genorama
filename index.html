<body>
<canvas id=a></canvas>
<script>
a.width = 640;
a.height = 320;
c = a.getContext("2d");

//
var W = "#4af",
	G = "#5a4",
	T = "#2604",
	R = "#666",
	S = "#DDA",
	O = "#07d",
	D = "#ab5",
	I = "#FFF",
	n;

// Set up permutation list.
var permutation = [];
for (n=512; n--;) {
	permutation[n] = ~~(Math.random() * 256);
}

/**
 * @param {number} x
 * @param {number} y
 * @param {number} f Frequency.
 * @param {number} o Octaves.
 * t is Total.
 */
function getHeight(x, y, f, o) {
	var t = 0;
	for (n=o; n--;) {
		t += noise(x*f, y*f);
		f *= 2;
	}
	return t;
}

/**
 *
 */
function gradient(h, u, v) {
	if ((h&=7)<=4) [u,v]=[v,u]
	return (h&1
		? -u + (h&2 ? -2 : 2)
		: u + (h&2 ? -2 : 2)) * v;
}

/**
 *
 */
function noise(x, y) {

	var s = (x+y)*0.366025403;
	var i = ~~(x + s);
	var j = ~~(y + s);

	var t = (i+j)*0.211324865;
	var x0 = x-(i-t);
	var y0 = y-(j-t);

	var i1 = (x0 > y0);

	var x1 = x0 - i1  + 0.211324865;
	var y1 = y0 - !i1 + 0.211324865;
	var x2 = x0 - 0.57735027;
	var y2 = y0 - 0.57735027;

	var ii = i & 255;
	var jj = j & 255;

	var plist = permutation;

	var total = 0;
	var t0 = 0.5 - x0*x0-y0*y0;
	if (t0 >= 0) {
		total += Math.pow(t0, 4) * gradient(plist[ii+plist[jj]], x0, y0);
	}

	var t1 = 0.5 - x1*x1-y1*y1;
	if (t1 >= 0) {
		total += Math.pow(t1, 4) * gradient(plist[ii+i1+plist[jj+!i1]], x1, y1);
	}

	var t2 = 0.5 - x2*x2-y2*y2;
	if (t2 >= 0) {
		total += Math.pow(t2, 4) * gradient(plist[ii+1+plist[jj+1]], x2, y2);
	}

	return 40 * total;

}

/**
 * @param {number} x
 * @param {number} y
 * Here we combine serveral layers of noise to produce the terrain for a given
 * cell. This is largely dark magic. A lot of layers directly depend on other
 * layers, so changing one part of it can change the rest in a kind of domino
 * effect.
 */
function generateCell(x, y) {

	x /= 4
	y /= 4

	// base
	var type = G;

	//
	var river = Math.pow(Math.abs(getHeight(x, y, 0.0025, 4)), 2.5);
	var tributary = Math.pow(Math.abs(getHeight(x, y, 0.04, 1)), 2);
	var moisture = river * 0.8 + getHeight(x, y, 0.16, 2) * 0.2;

	// forests
	var forest = getHeight(x, y, 0.005, 3);

	// mountain
	var height = 1 + getHeight(x, y, 0.04, 1) * 0.4;
	height += getHeight(x, y, 0.02, 1) * 0.6;
	height += getHeight(x, y, 0.16, 1) * 0.6;
	height *= river;

	// hills
	height += 0.5 + getHeight(y, x, 0.16, 1) * 0.5;
	height += 0.8;

	// rivers
	tributary += river * 0.2;
	//height -= (1 + getHeight(x, y, 0.08, 1)) * 0.2;

	height -= Math.pow(100, getHeight(x, y, 0.001, 1));
	if (moisture > 1) type = D;
	if (river < 0.005) type = W;
	if (tributary < 0.025) type = W;
	if (height <= -1.2) type = S;
	if (forest > 0.6 || (forest > 0.1 && moisture < 0)) type = T;
	if (height <= -1.5) type = W;
	if (height <= -4) type = O;
	if (height > 2) type = R;
	if (height > 8) type = I;

	return {
		t: type,
		h: type === T ? height+5
			: type === W || type === O || type === S ? 1//height/4
			: Math.max(1, height*2)
	}

}

c.font = "40px serif";
c.textAlign = "center";
c.fillText("Painting happy trees!", 320, 160)

var X = 0;
var A = 0;
function step() {

	// Fade in terrain, just provides a nic fast transition, as opposed to
	// waiting for a full view to be drawn.
	if (A < 1) A += 0.002;

	// Move draw across.
	X++;

	// Draw canvas shifted to left.
	c.globalAlpha = 1;
	c.globalCompositeOperation = "copy";
	c.drawImage(a, -1, 0);

	// Draw new cells (that are "coming in").
	c.globalCompositeOperation = "source-over";
	c.globalAlpha = A;
	for (var y=0; y<340; y++) {
		var cell = generateCell(X, y*4);
		var shadow = Math.max(
			generateCell(X+10, y*4+10).h,
			generateCell(X+20, y*4+20).h,
			generateCell(X+30, y*4+30).h,
			generateCell(X+40, y*4+40).h
		);

		// We use "9" as the height here because it's a single char and happens
		// to be enough! :P

		// Color.
		c.fillStyle = cell.t;
		c.fillRect(639, y-cell.h, 1, 9);

		// Shadow.
		if (cell.h < shadow) {
			c.fillStyle = "rgba(0,0,0,"+shadow/50+")";
			c.fillRect(639, y-cell.h, 1, 9);
		}

	}

}

// Wait a bit, then start a loop.
setTimeout(_ => setInterval(step, 10), 1000)

</script>
</body>
